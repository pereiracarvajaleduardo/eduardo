// static/measure_tool/js/script.js

// MUY IMPORTANTE: Ajusta esta ruta de importación según tu estructura de archivos final.
// Asumiendo: static/measure_tool/js/script.js y static/lib/pdfjs/build/pdf.mjs
import * as pdfjsLib from '/static/lib/pdfjs/build/pdf.mjs'; // Ruta absoluta desde la raíz del sitio

// --- CONFIGURACIÓN INICIAL ---
if (typeof pdfjsLib !== 'undefined') {
    if (typeof PDF_WORKER_URL !== 'undefined' && PDF_WORKER_URL) {
        pdfjsLib.GlobalWorkerOptions.workerSrc = PDF_WORKER_URL;
        console.log("PDF.js workerSrc configurado a:", PDF_WORKER_URL);
    } else {
        console.error("FATAL: PDF_WORKER_URL no está definida por Flask. El visor de PDF no funcionará.");
    }
} else {
    console.error("FATAL: pdfjsLib no está definido. Verifica la importación de PDF.js.");
}

let currentRenderScale = 1.5;
const ZOOM_FACTOR = 0.25;

// --- CONSTANTES ---
const DEFAULT_CURSOR = 'default';
const PRECISE_CURSOR = 'crosshair';
const CALIBRATION_POINT_COLOR = 'rgba(255, 0, 0, 0.7)';
const MEASUREMENT_POINT_COLOR = 'rgba(0, 0, 255, 0.7)';
const MEASUREMENT_LINE_COLOR = 'blue';
const AREA_POLYGON_COLOR_FILL = 'rgba(0, 128, 0, 0.3)';
const AREA_LINE_COLOR = 'green';
const CIRCLE_FILL_COLOR = 'rgba(255, 165, 0, 0.3)';
const CIRCLE_LINE_COLOR = 'orange';
const CANVAS_POINT_RADIUS_BASE = 5;
const TEXT_BG_COLOR_MEASUREMENTS = '#ffffffaa';

// --- ELEMENTOS DEL DOM ---
const pdfFileInput = document.getElementById('pdf-file-input');
const pdfLoadSection = document.getElementById('pdf-load-section');
const canvas = document.getElementById('pdf-canvas');
const context = canvas ? canvas.getContext('2d') : null;
const screenCoordsEl = document.getElementById('screen-coords');
const pdfCoordsEl = document.getElementById('pdf-coords');
const measureDistanceBtn = document.getElementById('measure-distance-btn');
const measureStatusEl = document.getElementById('measure-status');
const measureCanvas = document.getElementById('measure-canvas');
const measureContext = measureCanvas ? measureCanvas.getContext('2d') : null;
const measurementsListEl = document.getElementById('measurements-list');
const clearMeasurementsBtn = document.getElementById('clear-measurements-btn');
const startCalibrateBtn = document.getElementById('start-calibrate-btn');
const calibrationStatusEl = document.getElementById('calibration-status');
const calibrationInputDiv = document.getElementById('calibration-input-div');
const knownLengthInput = document.getElementById('known-length');
const setScaleBtn = document.getElementById('set-scale-btn');
const predefinedScaleSelect = document.getElementById('predefined-scale');
const applyPredefinedScaleBtn = document.getElementById('apply-predefined-scale-btn');
const knownUnitSelect = document.getElementById('known-unit');
const currentScaleInfoEl = document.getElementById('current-scale-info');
const zoomInBtn = document.getElementById('zoom-in-btn');
const zoomOutBtn = document.getElementById('zoom-out-btn');
const zoomLevelInfoEl = document.getElementById('zoom-level-info');
const measureAreaBtn = document.getElementById('measure-area-btn');
const measureCircleBtn = document.getElementById('measure-circle-btn');
const finishShapeBtn = document.getElementById('finish-shape-btn');

// NUEVO: Elementos del DOM para Paginación
const prevPageBtn = document.getElementById('prev-page-btn');
const nextPageBtn = document.getElementById('next-page-btn');
const pageNumEl = document.getElementById('page-num');
const pageCountEl = document.getElementById('page-count');
const goToPageInput = document.getElementById('go-to-page-input');
const goToPageBtn = document.getElementById('go-to-page-btn');

// --- ESTADO DE LA APLICACIÓN ---
let pdfDoc = null;
let currentPageNum = 1; // Se mantiene para la paginación
let pageRendering = false;
let pageNumPending = null;
let currentViewport = null;
let currentPdfSource = null;

let isCalibrating = false;
let calibrationPoints = [];
let scaleFactor = null;
let realWorldUnit = '';

let isMeasuringDistance = false;
let measurementPoints = [];

let isMeasuringArea = false;
let areaPoints = [];

let isMeasuringCircle = false;
let circlePoints = [];

let allMeasurements = [];

// --- FUNCIONES DE PAGINACIÓN (NUEVAS Y/O MODIFICADAS) ---
function updatePaginationControls() {
    if (!pdfDoc || !pageNumEl || !pageCountEl || !prevPageBtn || !nextPageBtn || !goToPageInput) {
        // Si algún elemento de paginación no existe, o no hay PDF, no hacer nada o desactivar.
        if(pageNumEl) pageNumEl.textContent = "-";
        if(pageCountEl) pageCountEl.textContent = "-";
        if(prevPageBtn) prevPageBtn.disabled = true;
        if(nextPageBtn) nextPageBtn.disabled = true;
        if(goToPageInput) goToPageInput.value = ""; goToPageInput.disabled = true;
        if(goToPageBtn) goToPageBtn.disabled = true;
        return;
    }
    pageNumEl.textContent = currentPageNum;
    pageCountEl.textContent = pdfDoc.numPages;

    prevPageBtn.disabled = (currentPageNum <= 1);
    nextPageBtn.disabled = (currentPageNum >= pdfDoc.numPages);
    goToPageInput.max = pdfDoc.numPages;
    goToPageInput.min = 1;
    goToPageInput.disabled = false;
    goToPageBtn.disabled = false;
}

// --- FUNCIONES DE RENDERIZADO DEL PDF ---
function renderPage(num) {
    if (!pdfDoc) {
        console.warn("renderPage llamado pero pdfDoc es null.");
        pageRendering = false;
        updatePaginationControls(); // Actualizar estado de botones
        return;
    }
    pageRendering = true;
    currentPageNum = num; // Asegurar que currentPageNum esté actualizado
    console.log(`Renderizando página ${num} con escala ${currentRenderScale}`);
    updatePaginationControls(); // Actualizar UI de paginación ANTES de obtener la página

    pdfDoc.getPage(num).then(function(page) {
        currentViewport = page.getViewport({ scale: currentRenderScale });
        console.log('Viewport creado. Ancho:', currentViewport.width, 'Alto:', currentViewport.height);
        if (canvas) {
            canvas.height = currentViewport.height;
            canvas.width = currentViewport.width;
        }
        if (measureCanvas) {
            measureCanvas.height = currentViewport.height;
            measureCanvas.width = currentViewport.width;
        }

        const renderContext = { canvasContext: context, viewport: currentViewport };
        const renderTask = page.render(renderContext);

        renderTask.promise.then(function() {
            console.log(`Página ${num} renderizada.`);
            pageRendering = false;
            if (pageNumPending !== null) {
                const pending = pageNumPending;
                pageNumPending = null; // Limpiar antes de la llamada recursiva
                renderPage(pending);
            }
            redrawAllScreenElements();
            updateZoomLevelInfo();
            // updatePaginationControls(); // Ya se llamó al inicio de renderPage
        }).catch(function(error) {
            console.error("Error AL RENDERIZAR la página:", error);
            pageRendering = false;
            updatePaginationControls(); // Actualizar en caso de error
        });
    }).catch(function(error) {
        console.error("Error AL OBTENER la página:", error);
        pageRendering = false;
        updatePaginationControls(); // Actualizar en caso de error
    });
}

function queueRenderPage(num) {
    if (pageRendering) {
        pageNumPending = num;
    } else {
        renderPage(num);
    }
}

function resetApplicationState() {
    pdfDoc = null;
    currentPageNum = 1;
    // currentRenderScale = 1.5; 
    
    scaleFactor = null;
    realWorldUnit = '';
    if(currentScaleInfoEl) currentScaleInfoEl.textContent = "No calibrada";
    if(calibrationStatusEl) calibrationStatusEl.textContent = 'Esperando inicio...';
    if(calibrationInputDiv) calibrationInputDiv.style.display = 'none';
    calibrationPoints = [];
    
    deactivateAllModes(); 

    measurementPoints = [];
    allMeasurements = [];
    
    clearMeasureCanvas();
    updateMeasurementsList();
    updateZoomLevelInfo(); 
    updatePaginationControls(); // Resetear controles de paginación
    
    if(measureCanvas) {
        measureCanvas.style.pointerEvents = 'none';
        measureCanvas.style.cursor = DEFAULT_CURSOR;
    }
    console.log('Estado de la aplicación reseteado.');
}

function loadAndRenderPdf(pdfSource) {
    if (!pdfSource) {
        console.warn("loadAndRenderPdf llamado sin fuente de PDF.");
        if(pdfLoadSection) pdfLoadSection.classList.remove('file-input-hidden');
        updatePaginationControls(); // Actualizar/deshabilitar paginación
        return;
    }
    console.log('Cargando PDF desde:', pdfSource);

    if (currentPdfSource && typeof currentPdfSource === 'string' && currentPdfSource.startsWith('blob:')) {
        URL.revokeObjectURL(currentPdfSource);
    }
    currentPdfSource = pdfSource;

    resetApplicationState(); // Esto ya llama a updatePaginationControls

    const loadingTask = pdfjsLib.getDocument(pdfSource);
    loadingTask.promise.then(function(pdfDoc_) {
        pdfDoc = pdfDoc_;
        console.log('PDF cargado:', pdfDoc.numPages, 'páginas.');
        currentPageNum = 1; // Siempre empezar en la página 1
        updatePaginationControls(); // Configurar paginación con el nuevo PDF
        queueRenderPage(currentPageNum);
    }).catch(function(reason) {
        console.error('Error al cargar el PDF:', reason);
        alert('Error al cargar el PDF: ' + (reason.message || 'Error desconocido. Revisa la consola.'));
        resetApplicationState(); // Esto resetea paginación
        if(pdfLoadSection) pdfLoadSection.classList.remove('file-input-hidden');
    });
}

// --- EVENTOS DE UI ---
if (pdfFileInput) {
    pdfFileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file && file.type === 'application/pdf') {
            if (currentPdfSource && typeof currentPdfSource === 'string' && currentPdfSource.startsWith('blob:')) {
                URL.revokeObjectURL(currentPdfSource); // Limpiar el anterior si se está recargando localmente
            }
            const fileURL = URL.createObjectURL(file);
            loadAndRenderPdf(fileURL);
        } else if (file) {
            alert('Por favor, selecciona un archivo PDF válido.');
        }
    });
}

// --- LÓGICA DE DIBUJO ---
function clearMeasureCanvas() {
    if(measureContext && measureCanvas) measureContext.clearRect(0, 0, measureCanvas.width, measureCanvas.height);
}

function getScreenPoint(pdfPoint) {
    if (!currentViewport || !pdfPoint || pdfPoint.length !== 2) return null;
    const viewportPoint = currentViewport.convertToViewportPoint(pdfPoint[0], pdfPoint[1]);
    return { x: viewportPoint[0], y: viewportPoint[1] };
}

function getScreenPoints(pdfPointsArray) {
    return pdfPointsArray.map(pdfPoint => getScreenPoint(pdfPoint)).filter(p => p !== null);
}

function drawPoint(screenPoint, color, ctx = measureContext) {
    if (!screenPoint || !currentViewport || !ctx) return;
    ctx.fillStyle = color;
    ctx.beginPath();
    const pointRadius = CANVAS_POINT_RADIUS_BASE / currentViewport.scale;
    ctx.arc(screenPoint.x, screenPoint.y, Math.max(2, pointRadius), 0, 2 * Math.PI);
    ctx.fill();
}

function drawLine(p1Screen, p2Screen, color, lineWidth = 2, ctx = measureContext) {
    if (!p1Screen || !p2Screen || !ctx) return;
    ctx.beginPath();
    ctx.moveTo(p1Screen.x, p1Screen.y);
    ctx.lineTo(p2Screen.x, p2Screen.y);
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.stroke();
}

function drawPolygon(screenPointsArray, lineColor, fillColor, lineWidth = 2, ctx = measureContext) {
    if (!screenPointsArray || screenPointsArray.length < 2 || !ctx) return;
    ctx.beginPath();
    ctx.moveTo(screenPointsArray[0].x, screenPointsArray[0].y);
    for (let i = 1; i < screenPointsArray.length; i++) {
        ctx.lineTo(screenPointsArray[i].x, screenPointsArray[i].y);
    }
    if (screenPointsArray.length > 2) {
        ctx.closePath();
    }
    if (fillColor) {
        ctx.fillStyle = fillColor;
        ctx.fill();
    }
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = lineWidth;
    ctx.stroke();
}

function drawCircle(centerScreen, radiusScreen, lineColor, fillColor, lineWidth = 2, ctx = measureContext) {
    if (!centerScreen || radiusScreen <= 0 || !ctx) return;
    ctx.beginPath();
    ctx.arc(centerScreen.x, centerScreen.y, radiusScreen, 0, 2 * Math.PI);
    if (fillColor) {
        ctx.fillStyle = fillColor;
        ctx.fill();
    }
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = lineWidth;
    ctx.stroke();
}

function drawText(text, positionScreen, color, font = '12px Arial', ctx = measureContext) {
    if (!text || !positionScreen || !ctx) return;
    ctx.fillStyle = color;
    ctx.font = font;
    ctx.fillText(text, positionScreen.x, positionScreen.y);
}

function drawMeasurementTextWithBackground(text, positionScreen, textColor, bgColor = TEXT_BG_COLOR_MEASUREMENTS, ctx = measureContext) {
    if (!text || !positionScreen || !ctx) return;
    const padding = 3;
    ctx.font = '12px Arial'; // Asegurar que la fuente esté seteada para measureText
    const textMetrics = ctx.measureText(text);
    const textWidth = textMetrics.width;
    // Aproximación de altura; puede ser más precisa con textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent
    const textHeight = 12; 

    ctx.fillStyle = bgColor;
    ctx.fillRect(
        positionScreen.x - padding, 
        positionScreen.y - textHeight - padding, // Posicionar texto encima del punto de referencia
        textWidth + 2 * padding, 
        textHeight + 2 * padding
    );
    drawText(text, {x: positionScreen.x, y: positionScreen.y - padding}, textColor, '12px Arial', ctx); // Ajustar Y para dibujar dentro del fondo
}


function redrawAllScreenElements() {
    clearMeasureCanvas();
    if (!currentViewport) return;

    allMeasurements.forEach(measurement => {
        const screenPoints = getScreenPoints(measurement.pointsPdf);
        if (screenPoints.length === 0) return;

        let textPos, midPoint;
        switch (measurement.type) {
            case 'distance':
                if (screenPoints.length === 2) {
                    drawLine(screenPoints[0], screenPoints[1], MEASUREMENT_LINE_COLOR);
                    midPoint = { x: (screenPoints[0].x + screenPoints[1].x) / 2, y: (screenPoints[0].y + screenPoints[1].y) / 2 };
                    drawMeasurementTextWithBackground(measurement.text, {x: midPoint.x, y: midPoint.y - 10}, MEASUREMENT_LINE_COLOR);
                }
                break;
            case 'area':
                if (screenPoints.length >= 3) {
                    drawPolygon(screenPoints, AREA_LINE_COLOR, AREA_POLYGON_COLOR_FILL);
                    if (measurement.text) {
                        let sumX = 0, sumY = 0;
                        screenPoints.forEach(p => { sumX += p.x; sumY += p.y; });
                        textPos = { x: sumX / screenPoints.length, y: sumY / screenPoints.length - 15 };
                        drawMeasurementTextWithBackground(measurement.text, textPos, AREA_LINE_COLOR);
                    }
                }
                break;
            case 'circle':
                if (measurement.centerPdf && typeof measurement.radiusPdf === 'number') {
                    const centerScreen = getScreenPoint(measurement.centerPdf);
                    const pointOnEdgePdf = [measurement.centerPdf[0] + measurement.radiusPdf, measurement.centerPdf[1]];
                    const pointOnEdgeScreen = getScreenPoint(pointOnEdgePdf);
                    if (centerScreen && pointOnEdgeScreen) {
                        const radiusScreen = Math.sqrt(Math.pow(pointOnEdgeScreen.x - centerScreen.x, 2) + Math.pow(pointOnEdgeScreen.y - centerScreen.y, 2));
                        if (radiusScreen > 0) {
                            drawCircle(centerScreen, radiusScreen, CIRCLE_LINE_COLOR, CIRCLE_FILL_COLOR);
                            if (measurement.text) {
                                textPos = { x: centerScreen.x, y: centerScreen.y - radiusScreen - 10 };
                                drawMeasurementTextWithBackground(measurement.text, textPos, CIRCLE_LINE_COLOR);
                            }
                        }
                    }
                }
                break;
        }
    });

    if (isCalibrating) {
        getScreenPoints(calibrationPoints).forEach(sp => drawPoint(sp, CALIBRATION_POINT_COLOR));
    } else if (isMeasuringDistance && measurementPoints.length > 0) {
        const tempDistScreenPoints = getScreenPoints(measurementPoints.map(p => p.pdf));
        tempDistScreenPoints.forEach(sp => drawPoint(sp, MEASUREMENT_POINT_COLOR));
        if (tempDistScreenPoints.length === 2) {
            drawLine(tempDistScreenPoints[0], tempDistScreenPoints[1], MEASUREMENT_LINE_COLOR);
        }
    } else if (isMeasuringArea && areaPoints.length > 0) {
        const tempAreaScreenPoints = getScreenPoints(areaPoints);
        tempAreaScreenPoints.forEach(sp => drawPoint(sp, AREA_LINE_COLOR));
        if (tempAreaScreenPoints.length > 1) {
            drawPolygon(tempAreaScreenPoints, AREA_LINE_COLOR, null); 
        }
    } else if (isMeasuringCircle && circlePoints.length > 0) {
        const tempCircleScreenPoints = getScreenPoints(circlePoints);
        tempCircleScreenPoints.forEach(sp => drawPoint(sp, CIRCLE_LINE_COLOR));
        
        if (circlePoints.length === 2) { // Centro y radio
            const centerS = tempCircleScreenPoints[0];
            const pointOnCircS = tempCircleScreenPoints[1];
            const radiusS = Math.sqrt(Math.pow(pointOnCircS.x - centerS.x, 2) + Math.pow(pointOnCircS.y - centerS.y, 2));
            if (radiusS > 0) drawCircle(centerS, radiusS, CIRCLE_LINE_COLOR, null);
        } else if (circlePoints.length === 3) { // 3 puntos en circunferencia
            const circleData = calculateCircleFrom3Points(circlePoints[0], circlePoints[1], circlePoints[2]);
            if (circleData) {
                const centerS = getScreenPoint(circleData.center);
                const pointOnEdgePdf = [circleData.center[0] + circleData.radius, circleData.center[1]];
                const pointOnEdgeScreen = getScreenPoint(pointOnEdgePdf);
                if (centerS && pointOnEdgeScreen) {
                    const radiusS = Math.sqrt(Math.pow(pointOnEdgeScreen.x - centerS.x, 2) + Math.pow(pointOnEdgeScreen.y - centerS.y, 2));
                    if (radiusS > 0) drawCircle(centerS, radiusS, CIRCLE_LINE_COLOR, null);
                }
            }
        }
    }
}

function updateMeasurementsList() {
    if(!measurementsListEl) return;
    measurementsListEl.innerHTML = '';
    allMeasurements.forEach((m, index) => {
        const listItem = document.createElement('li');
        listItem.textContent = `Medición ${index + 1} (${m.type}): ${m.text}`;
        measurementsListEl.appendChild(listItem);
    });
}

function deactivateAllModes(preserveCalibration = false) {
    isMeasuringDistance = false;
    isMeasuringArea = false;
    isMeasuringCircle = false;

    if (!preserveCalibration) {
        isCalibrating = false;
        calibrationPoints = [];
        if (calibrationInputDiv) calibrationInputDiv.style.display = 'none';
        if (calibrationStatusEl) calibrationStatusEl.textContent = 'Esperando inicio...';
    }
    
    const buttonsToReset = [
        { btn: measureDistanceBtn, text: 'Medir Distancia' },
        { btn: measureAreaBtn, text: 'Medir Área' },
        { btn: measureCircleBtn, text: 'Medir Círculo' }
    ];
    buttonsToReset.forEach(item => {
        if (item.btn) {
            item.btn.textContent = item.text;
            item.btn.style.backgroundColor = ''; // Vuelve al default CSS
        }
    });
    
    if(measureStatusEl) measureStatusEl.textContent = '';
    if(finishShapeBtn) finishShapeBtn.style.display = 'none';

    measurementPoints = []; 
    areaPoints = [];        
    circlePoints = [];      

    const anyUserInteractionModeActive = isMeasuringDistance || isMeasuringArea || isMeasuringCircle || isCalibrating;
    if (measureCanvas) {
        if (anyUserInteractionModeActive) {
            measureCanvas.style.pointerEvents = 'auto';
            measureCanvas.style.cursor = PRECISE_CURSOR;
        } else {
            measureCanvas.style.pointerEvents = 'none';
            measureCanvas.style.cursor = DEFAULT_CURSOR;
        }
    }
    redrawAllScreenElements();
}

// --- MANEJADORES DE EVENTOS PARA BOTONES ---
if (measureDistanceBtn) {
    measureDistanceBtn.addEventListener('click', function() {
        if (!pdfDoc) { alert("Carga un PDF primero."); return; }
        if (scaleFactor === null && !isCalibrating) { 
            alert("Por favor, calibra o aplica una escala primero."); return; 
        }
        const activating = !isMeasuringDistance;
        deactivateAllModes(true); 
        isMeasuringDistance = activating;
        measurementPoints = []; 
        if (isMeasuringDistance) {
            measureDistanceBtn.textContent = 'Cancelar Medición Dist.';
            measureDistanceBtn.style.backgroundColor = '#dc3545';
            measureStatusEl.textContent = 'Distancia: Clic en el PRIMER punto.';
        }
        // Actualizar cursor y pointerEvents se maneja en deactivateAllModes
        deactivateAllModes(true); // Llama de nuevo para actualizar cursor/pointerEvents basado en nuevo estado
        isMeasuringDistance = activating; // Restaurar el estado que queremos
         if(isMeasuringDistance && measureCanvas) { // Asegurar que si está activo, los eventos estén listos
            measureCanvas.style.pointerEvents = 'auto';
            measureCanvas.style.cursor = PRECISE_CURSOR;
        }
        redrawAllScreenElements();
    });
}

if (startCalibrateBtn) {
    startCalibrateBtn.addEventListener('click', function() {
        if (!pdfDoc) { alert("Carga un PDF primero."); return; }
        const activating = !isCalibrating;
        deactivateAllModes(); 
        isCalibrating = activating;
        calibrationPoints = []; 
        if (isCalibrating) {
            calibrationStatusEl.textContent = 'Calibración: Clic en el PRIMER punto.';
            currentScaleInfoEl.textContent = "Calibrando visualmente...";
            if(calibrationInputDiv) calibrationInputDiv.style.display = 'block';
            if(knownLengthInput) knownLengthInput.value = ''; 
        }
        deactivateAllModes(); // Llama de nuevo para actualizar cursor/pointerEvents
        isCalibrating = activating; // Restaurar
        if(isCalibrating && measureCanvas) {
             measureCanvas.style.pointerEvents = 'auto';
            measureCanvas.style.cursor = PRECISE_CURSOR;
        }
        redrawAllScreenElements();
    });
}

if (setScaleBtn) {
    setScaleBtn.addEventListener('click', function() {
        if (calibrationPoints.length < 2) {
            alert("Por favor, selecciona dos puntos en el PDF para la calibración visual."); return;
        }
        const p1_pdf = calibrationPoints[0];
        const p2_pdf = calibrationPoints[1];
        const knownLength = parseFloat(knownLengthInput.value);
        const selectedUnit = knownUnitSelect.value || 'unidades';

        if (isNaN(knownLength) || knownLength <= 0) {
            alert('Ingresa una longitud real válida y positiva.');
            if(calibrationStatusEl) calibrationStatusEl.textContent = 'Error en longitud. Intenta calibrar.';
            if(knownLengthInput) knownLengthInput.focus();
            return;
        }
        const deltaX_pdf = p2_pdf[0] - p1_pdf[0];
        const deltaY_pdf = p2_pdf[1] - p1_pdf[1];
        const distanceInPdfUnits = Math.sqrt(deltaX_pdf * deltaX_pdf + deltaY_pdf * deltaY_pdf);

        if (distanceInPdfUnits === 0) {
            alert('Los puntos de calibración son idénticos. Intenta de nuevo.');
            deactivateAllModes(); 
            return;
        }
        scaleFactor = knownLength / distanceInPdfUnits;
        realWorldUnit = selectedUnit;
        if(currentScaleInfoEl) currentScaleInfoEl.textContent = `Visual: 1u PDF ≈ ${scaleFactor.toFixed(4)} ${realWorldUnit}`;
        if(calibrationStatusEl) calibrationStatusEl.textContent = 'Escala visual fijada.';
        deactivateAllModes();
    });
}

if (applyPredefinedScaleBtn) {
    applyPredefinedScaleBtn.addEventListener('click', function() {
        if (!pdfDoc) { alert("Carga un PDF primero."); return; }
        const selectedScaleRatio = predefinedScaleSelect.value;
        const selectedUnit = knownUnitSelect.value || 'unidades';
        if (!selectedScaleRatio) { alert("Por favor, selecciona una escala predefinida."); return; }

        scaleFactor = parseFloat(selectedScaleRatio);
        realWorldUnit = selectedUnit;
        if(currentScaleInfoEl) currentScaleInfoEl.textContent = `Predef: 1:${scaleFactor} (${realWorldUnit})`;
        if(calibrationStatusEl) calibrationStatusEl.textContent = 'Escala predefinida aplicada.';
        deactivateAllModes();
    });
}

if (clearMeasurementsBtn) {
    clearMeasurementsBtn.addEventListener('click', function() {
        allMeasurements = [];
        updateMeasurementsList();
        redrawAllScreenElements();
    });
}

if (measureAreaBtn) {
    measureAreaBtn.addEventListener('click', function() {
        if (!pdfDoc) { alert("Carga un PDF primero."); return; }
        if (scaleFactor === null) { alert("Calibra la escala primero."); return; }
        const activating = !isMeasuringArea;
        deactivateAllModes(true); 
        isMeasuringArea = activating;
        areaPoints = [];
        if (isMeasuringArea) {
            measureAreaBtn.textContent = 'Cancelar Área';
            measureAreaBtn.style.backgroundColor = '#dc3545';
            measureStatusEl.textContent = 'Área: Clic para añadir puntos (mín. 3). Luego "Finalizar Forma".';
            if(finishShapeBtn) finishShapeBtn.style.display = 'inline-block';
        }
        deactivateAllModes(true);
        isMeasuringArea = activating;
        if(isMeasuringArea && measureCanvas) {
            measureCanvas.style.pointerEvents = 'auto';
            measureCanvas.style.cursor = PRECISE_CURSOR;
             if(finishShapeBtn) finishShapeBtn.style.display = 'inline-block'; // Asegurar que se muestre
        }
        redrawAllScreenElements();
    });
}

if (measureCircleBtn) {
    measureCircleBtn.addEventListener('click', function() {
        if (!pdfDoc) { alert("Carga un PDF primero."); return; }
        if (scaleFactor === null) { alert("Calibra la escala primero."); return; }
        const activating = !isMeasuringCircle;
        deactivateAllModes(true);
        isMeasuringCircle = activating;
        circlePoints = [];
        if (isMeasuringCircle) {
            measureCircleBtn.textContent = 'Cancelar Círculo';
            measureCircleBtn.style.backgroundColor = '#dc3545';
            measureStatusEl.textContent = 'Círculo: Clic 2 pts (centro, radio) o 3 pts (circunf.). Luego "Finalizar Forma".';
            if(finishShapeBtn) finishShapeBtn.style.display = 'inline-block';
        }
        deactivateAllModes(true);
        isMeasuringCircle = activating;
         if(isMeasuringCircle && measureCanvas) {
            measureCanvas.style.pointerEvents = 'auto';
            measureCanvas.style.cursor = PRECISE_CURSOR;
            if(finishShapeBtn) finishShapeBtn.style.display = 'inline-block'; // Asegurar que se muestre
        }
        redrawAllScreenElements();
    });
}

if (finishShapeBtn) {
    finishShapeBtn.addEventListener('click', function() {
        let calculated = false;
        if (isMeasuringArea && areaPoints.length >= 3) {
            calculateAndStoreArea();
            calculated = true;
        } else if (isMeasuringCircle && (circlePoints.length === 2 || circlePoints.length === 3)) {
            calculateAndStoreCircle();
            calculated = true;
        } else {
            if (isMeasuringArea) alert("Área: Se necesitan al menos 3 puntos.");
            else if (isMeasuringCircle) alert("Círculo: Se necesitan 2 o 3 puntos.");
            else if(measureStatusEl) measureStatusEl.textContent = "Ninguna forma activa para finalizar.";
        }
        if (calculated) {
             // Los modos específicos se desactivan dentro de sus funciones 'calculateAndStore...'
             // Llama a deactivateAllModes aquí para asegurar que el cursor y pointerEvents se reseteen si todos los modos terminaron.
             deactivateAllModes(true); // Preserva calibración si aún está activa por alguna razón (aunque no debería)
        }
    });
}

// --- CÁLCULOS GEOMÉTRICOS ---
function calculateAndStoreArea() {
    if (areaPoints.length < 3) {
        if(measureStatusEl) measureStatusEl.textContent = "Área: Se necesitan al menos 3 puntos.";
        return;
    }
    let areaPdf = 0;
    for (let i = 0; i < areaPoints.length; i++) {
        const p1 = areaPoints[i];
        const p2 = areaPoints[(i + 1) % areaPoints.length];
        areaPdf += (p1[0] * p2[1] - p2[0] * p1[1]);
    }
    areaPdf = Math.abs(areaPdf / 2);
    const areaReal = areaPdf * scaleFactor * scaleFactor;
    const areaText = `${areaReal.toFixed(2)} ${realWorldUnit}²`;

    allMeasurements.push({ type: 'area', pointsPdf: [...areaPoints], text: areaText });
    updateMeasurementsList();
    if(measureStatusEl) measureStatusEl.textContent = `Área: ${areaText}.`;
    
    isMeasuringArea = false; // Importante: desactivar el modo específico
    // No llamar a deactivateAllModes() aquí directamente, sino dejar que finishShapeBtn lo haga
    // o que se haga al cambiar a otra herramienta.
    // Por ahora, la lógica de finishShapeBtn ya llama a deactivateAllModes(true) si calculated = true.
    redrawAllScreenElements();
}

function calculateCircleFrom3Points(p1, p2, p3) {
    const [x1, y1] = p1, [x2, y2] = p2, [x3, y3] = p3;
    const D = 2 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));
    if (Math.abs(D) < 1e-8) { console.warn("Puntos colineales para círculo."); return null; }

    const commonFactor1 = x1 * x1 + y1 * y1;
    const commonFactor2 = x2 * x2 + y2 * y2;
    const commonFactor3 = x3 * x3 + y3 * y3;

    const centerX = (commonFactor1 * (y2 - y3) + commonFactor2 * (y3 - y1) + commonFactor3 * (y1 - y2)) / D;
    const centerY = (commonFactor1 * (x3 - x2) + commonFactor2 * (x1 - x3) + commonFactor3 * (x2 - x1)) / D;
    const radius = Math.sqrt(Math.pow(x1 - centerX, 2) + Math.pow(y1 - centerY, 2));
    return { center: [centerX, centerY], radius: radius };
}

function calculateAndStoreCircle() {
    let circleDataPdf = null;
    if (circlePoints.length === 2) {
        const center_pdf = circlePoints[0];
        const point_on_radius_pdf = circlePoints[1];
        const radius_pdf = Math.sqrt(
            Math.pow(point_on_radius_pdf[0] - center_pdf[0], 2) +
            Math.pow(point_on_radius_pdf[1] - center_pdf[1], 2)
        );
        if (radius_pdf === 0) { alert("El radio del círculo no puede ser cero."); return; }
        circleDataPdf = { center: center_pdf, radius: radius_pdf };
    } else if (circlePoints.length === 3) {
        circleDataPdf = calculateCircleFrom3Points(circlePoints[0], circlePoints[1], circlePoints[2]);
        if (!circleDataPdf) { alert("No se pudo calcular el círculo (puntos posiblemente colineales)."); return; }
    } else {
        if(measureStatusEl) measureStatusEl.textContent = "Círculo: Se necesitan 2 o 3 puntos."; return;
    }

    const radiusReal = circleDataPdf.radius * scaleFactor;
    const circumferenceReal = 2 * Math.PI * radiusReal;
    const areaCircleReal = Math.PI * Math.pow(radiusReal, 2);
    const circleText = `Circ: ${circumferenceReal.toFixed(2)} ${realWorldUnit}, Área: ${areaCircleReal.toFixed(2)} ${realWorldUnit}²`;

    allMeasurements.push({
        type: 'circle',
        pointsPdf: [...circlePoints],
        centerPdf: circleDataPdf.center,
        radiusPdf: circleDataPdf.radius,
        text: circleText
    });
    updateMeasurementsList();
    if(measureStatusEl) measureStatusEl.textContent = `Círculo: ${circleText}.`;
    
    isMeasuringCircle = false; // Importante: desactivar el modo específico
    redrawAllScreenElements();
}

// --- MANEJADOR DE CLICS EN EL MEASURE CANVAS ---
if (measureCanvas) {
    measureCanvas.addEventListener('click', function(event) {
        // console.log("CLIC. Cal:", isCalibrating, "Dist:", isMeasuringDistance, "Área:", isMeasuringArea, "Círculo:", isMeasuringCircle);

        if (!currentViewport || !pdfDoc) {
             console.warn("Clic ignorado: Viewport o PDF no listos.");
             return;
        }
        if (!isCalibrating && !isMeasuringDistance && !isMeasuringArea && !isMeasuringCircle) {
            // console.log("Clic ignorado: Ningún modo de medición/calibración activo.");
            return;
        }

        const rect = measureCanvas.getBoundingClientRect();
        const x_screen = event.clientX - rect.left;
        const y_screen = event.clientY - rect.top;
        const pdfPoint = currentViewport.convertToPdfPoint(x_screen, y_screen);

        if(screenCoordsEl) screenCoordsEl.textContent = `X: ${x_screen.toFixed(2)}, Y: ${y_screen.toFixed(2)}`;
        if(pdfCoordsEl) pdfCoordsEl.textContent = `X: ${pdfPoint[0].toFixed(2)}, Y: ${pdfPoint[1].toFixed(2)}`;

        if (isCalibrating) {
            if (calibrationPoints.length < 2) {
                calibrationPoints.push(pdfPoint);
                if (calibrationPoints.length === 1) {
                    if(calibrationStatusEl) calibrationStatusEl.textContent = 'Calibración: PRIMER punto. Clic en el SEGUNDO.';
                } else if (calibrationPoints.length === 2) {
                    if(calibrationStatusEl) calibrationStatusEl.textContent = 'Calibración: SEGUNDO punto. Ingresa longitud y fija escala.';
                    if(knownLengthInput) knownLengthInput.focus();
                }
            }
        } else if (isMeasuringDistance) {
            measurementPoints.push({ pdf: pdfPoint });
            if (measurementPoints.length === 1) {
                if(measureStatusEl) measureStatusEl.textContent = 'Distancia: PRIMER punto. Clic en el SEGUNDO.';
            } else if (measurementPoints.length === 2) {
                const p1_pdf = measurementPoints[0].pdf;
                const p2_pdf = measurementPoints[1].pdf;
                const deltaX_pdf = p2_pdf[0] - p1_pdf[0];
                const deltaY_pdf = p2_pdf[1] - p1_pdf[1];
                const distPdf = Math.sqrt(deltaX_pdf * deltaX_pdf + deltaY_pdf * deltaY_pdf);
                
                if (scaleFactor === null) { 
                    alert("Error: Escala no definida. Por favor, calibra o aplica una escala antes de medir."); 
                    deactivateAllModes(); // Resetea el modo de medición de distancia
                    return; 
                }
                const realDist = distPdf * scaleFactor;
                const distText = `${realDist.toFixed(2)} ${realWorldUnit}`;
                
                allMeasurements.push({ type: 'distance', pointsPdf: [p1_pdf, p2_pdf], text: distText });
                updateMeasurementsList();
                if(measureStatusEl) measureStatusEl.textContent = `Distancia: ${distText}. Clic para nueva medición o cancela.`;
                measurementPoints = []; 
            }
        } else if (isMeasuringArea) {
            areaPoints.push(pdfPoint);
            if(measureStatusEl) measureStatusEl.textContent = `Área: ${areaPoints.length} puntos. Clic para más, o "Finalizar Forma".`;
        } else if (isMeasuringCircle) {
            if (circlePoints.length < 3) { 
                circlePoints.push(pdfPoint);
                if(measureStatusEl) measureStatusEl.textContent = `Círculo: ${circlePoints.length} puntos. (2 para centro-radio, 3 para circunf.). "Finalizar Forma".`;
            } else {
                if(measureStatusEl) measureStatusEl.textContent = `Círculo: Ya tienes 3 puntos. Usa "Finalizar Forma".`;
            }
        }
        redrawAllScreenElements();
    });
}

// --- FUNCIONES DE ZOOM ---
function updateZoomLevelInfo() {
    if (zoomLevelInfoEl) {
        const scaleToDisplay = currentViewport ? currentViewport.scale : currentRenderScale;
        zoomLevelInfoEl.textContent = `Escala PDF: ${Math.round(scaleToDisplay * 100)}%`;
    }
}

if (zoomInBtn) {
    zoomInBtn.addEventListener('click', function() {
        if (!pdfDoc) return;
        currentRenderScale += ZOOM_FACTOR;
        queueRenderPage(currentPageNum);
    });
}

if (zoomOutBtn) {
    zoomOutBtn.addEventListener('click', function() {
        if (!pdfDoc) return;
        if (currentRenderScale - ZOOM_FACTOR >= ZOOM_FACTOR / 2) { // Evitar escala demasiado pequeña (ej. no menos de 12.5%)
            currentRenderScale -= ZOOM_FACTOR;
            queueRenderPage(currentPageNum);
        } else {
            console.warn("Zoom mínimo alcanzado.");
            if(measureStatusEl) measureStatusEl.textContent = "Zoom mínimo alcanzado.";
        }
    });
}

// --- INICIALIZACIÓN DEL SCRIPT ---
document.addEventListener('DOMContentLoaded', () => {
    // Verificar que los elementos del DOM existan antes de añadir listeners o manipularlos
    if (!canvas || !measureCanvas || !context || !measureContext) {
        console.error("Error crítico: Uno o más elementos canvas o sus contextos no se encontraron. La herramienta no funcionará.");
        alert("Error al inicializar la herramienta de medición. Revisa la consola.");
        return;
    }

    // Resetear la UI de botones de herramientas al estado inicial
    if(measureDistanceBtn) measureDistanceBtn.textContent = 'Medir Distancia';
    if(measureAreaBtn) measureAreaBtn.textContent = 'Medir Área';
    if(measureCircleBtn) measureCircleBtn.textContent = 'Medir Círculo';
    if(finishShapeBtn) finishShapeBtn.style.display = 'none';
    
    updateZoomLevelInfo();

    if (typeof PDF_URL_TO_LOAD !== 'undefined' && PDF_URL_TO_LOAD) {
        console.log("Cargando PDF desde URL (Flask):", PDF_URL_TO_LOAD);
        if (pdfLoadSection) {
             pdfLoadSection.classList.add('file-input-hidden'); // Ocultar input local
        }
        loadAndRenderPdf(PDF_URL_TO_LOAD);
    } else {
        console.log("No se proporcionó PDF_URL_TO_LOAD. Esperando carga local.");
        if (pdfLoadSection) {
            pdfLoadSection.classList.remove('file-input-hidden');
        }
    }
    console.log("Script de medición cargado y DOM listo.");
});