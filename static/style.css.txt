// static/measure_tool/js/script.js

// --- 1. CONFIGURACIÓN E IMPORTACIÓN ---
import * as pdfjsLib from '/static/lib/pdfjs/build/pdf.mjs';

if (typeof pdfjsLib !== 'undefined' && typeof PDF_WORKER_URL !== 'undefined' && PDF_WORKER_URL) {
    pdfjsLib.GlobalWorkerOptions.workerSrc = PDF_WORKER_URL;
} else {
    console.error("FATAL: PDF.js o su worker no están configurados correctamente.");
    alert("Error crítico al cargar el visor de PDF. Revisa la consola (F12).");
}

// --- 2. CONSTANTES DE CONFIGURACIÓN ---
const RENDER_SCALE_INITIAL = 1.5;
const ZOOM_FACTOR = 0.25;
const DEFAULT_CURSOR = 'default';
const PRECISE_CURSOR = 'crosshair';
const GRABBING_CURSOR = 'grabbing';
const POINT_COLOR_CALIBRATE = 'rgba(255, 0, 0, 0.7)';
const POINT_COLOR_MEASURE = 'rgba(0, 0, 255, 0.7)';
const LINE_COLOR_MEASURE = 'blue';
const LINE_COLOR_SELECTED = 'purple';
const FILL_COLOR_AREA = 'rgba(0, 128, 0, 0.3)';
const LINE_COLOR_AREA = 'green';
const POINT_RADIUS = 4;
const DRAG_HANDLE_RADIUS = 8;
const TEXT_BG_COLOR = 'rgba(255, 255, 255, 0.8)';
const TEXT_COLOR = '#000000';
const TEXT_FONT = '12px Arial';

// --- 3. ELEMENTOS DEL DOM ---
const pdfFileInput = document.getElementById('pdf-file-input');
const loadedPdfNameEl = document.getElementById('loaded-pdf-name');
const canvas = document.getElementById('pdf-canvas');
const context = canvas.getContext('2d');
const measureCanvas = document.getElementById('measure-canvas');
const measureContext = measureCanvas.getContext('2d');
const startCalibrateBtn = document.getElementById('start-calibrate-btn');
const measureDistanceBtn = document.getElementById('measure-distance-btn');
const measureAreaBtn = document.getElementById('measure-area-btn');
const finishShapeBtn = document.getElementById('finish-shape-btn');
const zoomInBtn = document.getElementById('zoom-in-btn');
const zoomOutBtn = document.getElementById('zoom-out-btn');
const prevPageBtn = document.getElementById('prev-page-btn');
const nextPageBtn = document.getElementById('next-page-btn');
const goToPageInput = document.getElementById('go-to-page-input');
const goToPageBtn = document.getElementById('go-to-page-btn');
const calibrationInputDiv = document.getElementById('calibration-input-div');
const knownLengthInput = document.getElementById('known-length');
const setScaleBtn = document.getElementById('set-scale-btn');
const predefinedScaleSelect = document.getElementById('predefined-scale');
const applyPredefinedScaleBtn = document.getElementById('apply-predefined-scale-btn');
const knownUnitSelect = document.getElementById('known-unit');
const currentScaleInfoEl = document.getElementById('current-scale-info');
const zoomLevelInfoEl = document.getElementById('zoom-level-info');
const pageNumEl = document.getElementById('page-num');
const pageCountEl = document.getElementById('page-count');
const measurementsListEl = document.getElementById('measurements-list');
const clearMeasurementsBtn = document.getElementById('clear-measurements-btn');

// --- 4. ESTADO GLOBAL DE LA APLICACIÓN ---
let pdfDoc = null;
let currentPageNum = 1;
let currentRenderScale = RENDER_SCALE_INITIAL;
let pageRendering = false;
let pageNumPending = null;
let currentViewport = null;
let currentMousePosPdf = null;
let scaleFactor = null;
let realWorldUnit = 'mm';

// Estado de la Herramienta (Refactorizado)
let currentTool = 'none'; // 'none', 'calibrate', 'distance', 'area'
let currentPoints = [];   // Puntos para la medición/calibración en curso

// Almacenamiento y Edición de Mediciones
let allMeasurements = [];
let selectedMeasurementIndex = -1;
let selectedPointIndex = -1;
let isDraggingPoint = false;


// --- 5. FUNCIONES PRINCIPALES ---

/**
 * Activa una herramienta o la desactiva si ya está activa.
 * @param {string} toolName - El nombre de la herramienta a activar.
 */
function setActiveTool(toolName) {
    if (currentTool === toolName) {
        toolName = 'none'; // Desactivar si se hace clic de nuevo
    }

    if (toolName !== 'none' && toolName !== 'calibrate' && !scaleFactor) {
        showTemporaryMessage("Por favor, calibra la escala primero.", 'warning');
        if (startCalibrateBtn) {
            startCalibrateBtn.classList.add('btn-pulse');
            setTimeout(() => {
                startCalibrateBtn.classList.remove('btn-pulse');
            }, 1200); // Duración de la animación
        }
        return; // Detenemos la activación de la herramienta
    }
    
    currentTool = toolName;
    currentPoints = [];
    selectedMeasurementIndex = -1;
    updateUI();
}

/**
 * Actualiza la UI (botones, cursor) para reflejar el estado actual.
 */
function updateUI() {
    [measureDistanceBtn, measureAreaBtn, startCalibrateBtn].forEach(btn => btn.classList.remove('active'));
    finishShapeBtn.style.display = 'none';
    measureCanvas.style.cursor = isDraggingPoint ? GRABBING_CURSOR : DEFAULT_CURSOR;

    switch (currentTool) {
        case 'calibrate':
            startCalibrateBtn.classList.add('active');
            measureCanvas.style.cursor = PRECISE_CURSOR;
            break;
        case 'distance':
            measureDistanceBtn.classList.add('active');
            measureCanvas.style.cursor = PRECISE_CURSOR;
            break;
        case 'area':
            measureAreaBtn.classList.add('active');
            finishShapeBtn.style.display = 'inline-block';
            measureCanvas.style.cursor = PRECISE_CURSOR;
            break;
    }
    redrawAllElements();
}

/**
 * Dibuja todos los elementos en el canvas: mediciones completadas y la medición en curso.
 */
function redrawAllElements() {
    if (!measureContext) return;
    measureContext.clearRect(0, 0, measureCanvas.width, measureCanvas.height);

    // Dibujar mediciones guardadas
    allMeasurements.forEach((m, index) => {
        if (m.pageNum !== currentPageNum) return;
        drawMeasurement(m, index === selectedMeasurementIndex);
    });

    // Dibujar medición/calibración en curso
    if (currentPoints.length > 0) {
        drawInProgress();
    }
}

/**
 * Carga y renderiza un archivo PDF desde una fuente (URL o File).
 * @param {string|object} pdfSource - La fuente del PDF.
 */
function loadAndRenderPdf(pdfSource) {
    resetApplicationState();
    pdfjsLib.getDocument(pdfSource).promise.then(pdfDoc_ => {
        pdfDoc = pdfDoc_;
        pageCountEl.textContent = pdfDoc.numPages;
        renderPage(1);
    }).catch(err => {
        console.error("Error al cargar el PDF:", err);
        alert("No se pudo cargar el archivo PDF.");
    });
}

/**
 * Renderiza una página específica del PDF.
 * @param {number} num - El número de la página a renderizar.
 */
function renderPage(num) {
    if (pageRendering) {
        pageNumPending = num;
        return;
    }
    pageRendering = true;
    currentPageNum = num;
    pageNumEl.textContent = num;

    pdfDoc.getPage(num).then(page => {
        currentViewport = page.getViewport({ scale: currentRenderScale });
        canvas.height = measureCanvas.height = currentViewport.height;
        canvas.width = measureCanvas.width = currentViewport.width;
        
        page.render({ canvasContext: context, viewport: currentViewport }).promise.then(() => {
            pageRendering = false;
            if (pageNumPending !== null) {
                renderPage(pageNumPending);
                pageNumPending = null;
            }
            redrawAllElements();
            zoomLevelInfoEl.textContent = `${(currentRenderScale * 100).toFixed(0)}%`;
        });
    });
}

// --- 6. MANEJADORES DE EVENTOS ---

/**
 * Maneja el evento mousedown en el canvas.
 */
function handleMouseDownOnCanvas(event) {
    if (!pdfDoc || event.button !== 0) return;
    const clickPdfPoint = getPdfPoint(event.clientX, event.clientY);
    if (!clickPdfPoint) return;

    // Lógica para seleccionar/arrastrar mediciones existentes
    if (currentTool === 'none') {
        if (tryToStartDrag(clickPdfPoint)) {
            event.preventDefault(); // Previene otros eventos si se inicia un arrastre
        } else {
            // Si no se inició un arrastre, deseleccionamos cualquier medida
            selectedMeasurementIndex = -1;
            redrawAllElements();
        }
        return; // Salimos de la función si no hay herramienta activa
    }
    
    // --- LÓGICA PARA HERRAMIENTAS ACTIVAS ---

    // Añadimos el punto actual a la medición en progreso
    currentPoints.push(clickPdfPoint);
    
    switch (currentTool) {
        case 'calibrate':
            if (currentPoints.length === 2) {
                calibrationInputDiv.style.display = 'block';
                // No limpiamos los puntos para que el usuario vea la línea que dibujó
            }
            break;

        case 'distance':
            // Finaliza la medición cuando se hace el segundo clic
            if (currentPoints.length === 2) {
                // Calculamos la distancia real usando el factor de escala
                const dist = calculateDistance(currentPoints[0], currentPoints[1]) * (scaleFactor || 1);
                
                // Creamos y guardamos la nueva medición
                allMeasurements.push({ 
                    type: 'distance', 
                    pointsPdf: [...currentPoints], 
                    value: dist, 
                    unit: realWorldUnit, 
                    pageNum: currentPageNum 
                });
                
                updateMeasurementsList(); // Actualizamos la lista en la UI
                setActiveTool('none');      // Desactivamos la herramienta para permitir nuevas acciones
            }
            break;

        case 'area':
            // Para el área, simplemente continuamos añadiendo puntos.
            // La finalización se maneja con el botón "OK" (finishShapeBtn).
            // No se necesita lógica adicional aquí, solo redibujar.
            break;
    }

    // Volvemos a dibujar todos los elementos para reflejar el nuevo punto
    redrawAllElements();
}

/**
 * Intenta iniciar el arrastre de un punto de una medida existente.
 * @param {object} clickPdfPoint - El punto donde se hizo clic.
 * @returns {boolean} - True si se inició el arrastre.
 */
function tryToStartDrag(clickPdfPoint) {
    for (let i = allMeasurements.length - 1; i >= 0; i--) {
        const m = allMeasurements[i];
        if (m.pageNum !== currentPageNum) continue;

        for (let j = 0; j < m.pointsPdf.length; j++) {
            const screenPoint = getScreenPoint(m.pointsPdf[j]);
            const clickScreenPoint = getScreenPoint(clickPdfPoint);
            const distance = Math.hypot(clickScreenPoint.x - screenPoint.x, clickScreenPoint.y - screenPoint.y);

            if (distance < DRAG_HANDLE_RADIUS) {
                isDraggingPoint = true;
                selectedMeasurementIndex = i;
                selectedPointIndex = j;
                document.addEventListener('mousemove', handleMouseMoveDocument);
                document.addEventListener('mouseup', handleMouseUpDocument);
                updateUI();
                return true;
            }
        }
    }
    return false;
}

/**
 * Maneja el movimiento del mouse en todo el documento durante un arrastre.
 */
function handleMouseMoveDocument(event) {
    if (!isDraggingPoint) return;
    const currentPdfMousePoint = getPdfPoint(event.clientX, event.clientY);
    if (!currentPdfMousePoint) return;

    const measurement = allMeasurements[selectedMeasurementIndex];
    measurement.pointsPdf[selectedPointIndex] = currentPdfMousePoint;
    
    // Recalcular el valor de la medida mientras se arrastra
    if(measurement.type === 'distance') {
        measurement.value = calculateDistance(measurement.pointsPdf[0], measurement.pointsPdf[1]) * (scaleFactor || 1);
    } else if (measurement.type === 'area' && measurement.pointsPdf.length > 2) {
        measurement.value = calculateAreaShoelace(measurement.pointsPdf) * (scaleFactor ? scaleFactor*scaleFactor : 1);
    }
    redrawAllElements();
}

/**
 * Maneja el evento mouseup en todo el documento para finalizar un arrastre.
 */
function handleMouseUpDocument(event) {
    isDraggingPoint = false;
    document.removeEventListener('mousemove', handleMouseMoveDocument);
    document.removeEventListener('mouseup', handleMouseUpDocument);
    updateMeasurementsList();
    updateUI();
}

// --- 7. FUNCIONES DE DIBUJO Y CÁLCULO (Auxiliares) ---

function getPdfPoint(clientX, clientY) {
    if (!currentViewport) return null;
    const rect = measureCanvas.getBoundingClientRect();
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    const pdfPoint = currentViewport.convertToPdfPoint(x, y);
    return { x: pdfPoint[0], y: pdfPoint[1] };
}

function drawMeasurement(measurement, isSelected) {
    const screenPoints = measurement.pointsPdf.map(p => getScreenPoint(p));
    const color = isSelected ? LINE_COLOR_SELECTED : LINE_COLOR_MEASURE;

    if (measurement.type === 'distance' && screenPoints.length === 2) {
        drawLine(screenPoints[0], screenPoints[1], color);
        const midPoint = { x: (screenPoints[0].x + screenPoints[1].x) / 2, y: (screenPoints[0].y + screenPoints[1].y) / 2 };
        drawText(`${measurement.value.toFixed(2)} ${measurement.unit}`, midPoint);
    } else if (measurement.type === 'area' && screenPoints.length > 1) {
        drawPolygon(screenPoints, LINE_COLOR_AREA, FILL_COLOR_AREA, true);
        const center = getPolygonCentroid(screenPoints);
        drawText(`${measurement.value.toFixed(2)} ${measurement.unit}²`, center);
    }

    if (isSelected) {
        screenPoints.forEach(p => drawPoint(p, LINE_COLOR_SELECTED, DRAG_HANDLE_RADIUS));
    }
}

function drawInProgress() {
    const screenPoints = currentPoints.map(p => getScreenPoint(p));
    if (screenPoints.length === 0) return;

    // Dibuja todos los puntos que el usuario ha hecho clic hasta ahora
    screenPoints.forEach(p => drawPoint(p, POINT_COLOR_CALIBRATE, POINT_RADIUS));

    // Si no hay una posición del mouse, no hay nada más que dibujar
    if (!currentMousePosPdf) return;
    const mouseScreenPos = getScreenPoint(currentMousePosPdf);

    const lastPoint = screenPoints[screenPoints.length - 1];
    const color = currentTool === 'calibrate' ? 'red' : 'blue';

    // --- LÓGICA DE DIBUJO DEPENDIENDO DE LA HERRAMIENTA ---
    switch(currentTool) {
        case 'calibrate':
        case 'distance':
            // Para calibración y distancia, solo dibujamos una línea desde el último punto al mouse
            if (screenPoints.length > 0) {
                 drawLine(lastPoint, mouseScreenPos, color, true); // Línea punteada
            }
            break;

        case 'area':
            // Para área, dibujamos el polígono en progreso
            if (screenPoints.length === 1) {
                // Si solo hay un punto, dibujamos una línea hasta el mouse
                drawLine(screenPoints[0], mouseScreenPos, color, true);
            } else if (screenPoints.length > 1) {
                // Si hay más de un punto, dibujamos el polígono completo
                const tempPoints = [...screenPoints, mouseScreenPos];
                drawPolygon(tempPoints, LINE_COLOR_AREA, FILL_COLOR_AREA, false); // Polígono abierto
                
                // Adicionalmente, dibujamos una línea punteada desde el mouse al primer punto
                // para que el usuario vea cómo se cerraría la forma.
                drawLine(mouseScreenPos, screenPoints[0], 'purple', true);
            }
            break;
    }
}

// Implementaciones de las funciones de dibujo y cálculo
function drawPoint(screenPoint, color, radius) {
    measureContext.beginPath();
    measureContext.arc(screenPoint.x, screenPoint.y, radius, 0, 2 * Math.PI);
    measureContext.fillStyle = color;
    measureContext.fill();
}
function drawLine(p1, p2, color, isDashed = false) {
    measureContext.beginPath();
    if(isDashed) measureContext.setLineDash([5, 5]);
    measureContext.moveTo(p1.x, p1.y);
    measureContext.lineTo(p2.x, p2.y);
    measureContext.strokeStyle = color;
    measureContext.lineWidth = 2;
    measureContext.stroke();
    if(isDashed) measureContext.setLineDash([]);
}
function drawPolygon(points, stroke, fill, close) {
    if (!points || points.length < 1) return;
    measureContext.beginPath();
    measureContext.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) {
        measureContext.lineTo(points[i].x, points[i].y);
    }
    if (close) measureContext.closePath();
    measureContext.strokeStyle = stroke;
    measureContext.lineWidth = 2;
    measureContext.stroke();
    if (fill) {
        measureContext.fillStyle = fill;
        measureContext.fill();
    }
}
function drawText(text, pos) {
    measureContext.font = TEXT_FONT;
    const width = measureContext.measureText(text).width;
    measureContext.fillStyle = TEXT_BG_COLOR;
    measureContext.fillRect(pos.x - width/2 - 2, pos.y - 14, width + 4, 14);
    measureContext.fillStyle = TEXT_COLOR;
    measureContext.textAlign = 'center';
    measureContext.fillText(text, pos.x, pos.y - 2);
}
function getPolygonCentroid(pts) { let first = pts[0], last = pts[pts.length - 1]; if (first.x != last.x || first.y != last.y) pts.push(first); let twicearea = 0, x = 0, y = 0, nPts = pts.length, p1, p2, f; for (let i = 0, j = nPts - 1; i < nPts; j = i++) { p1 = pts[i]; p2 = pts[j]; f = p1.x * p2.y - p2.x * p1.y; twicearea += f; x += (p1.x + p2.x) * f; y += (p1.y + p2.y) * f; } f = twicearea * 3; return { x: x / f, y: y / f }; }
function getScreenPoint(pdfPoint) { if (!currentViewport) return null; const sp = currentViewport.convertToViewportPoint(pdfPoint.x, pdfPoint.y); return {x: sp[0], y: sp[1]}; }
function calculateDistance(p1, p2) { return Math.hypot(p2.x - p1.x, p2.y - p1.y); }
function calculateAreaShoelace(points) { let area = 0; for (let i = 0; i < points.length; i++) { const j = (i + 1) % points.length; area += points[i].x * points[j].y; area -= points[j].x * points[i].y; } return Math.abs(area / 2); }
function updateMeasurementsList() { measurementsListEl.innerHTML = ''; allMeasurements.forEach((m, i) => { const li = document.createElement('li'); li.className = 'list-group-item'; li.textContent = `Medida ${i + 1}: ${m.value.toFixed(2)} ${m.unit}${m.type==='area'?'²':''}`; measurementsListEl.appendChild(li); }); }
function resetApplicationState() { pdfDoc=null; currentPageNum=1; pageNumPending=null; currentViewport=null; currentTool='none'; currentPoints=[]; allMeasurements=[]; selectedMeasurementIndex=-1; selectedPointIndex=-1; isDraggingPoint=false; scaleFactor=null; realWorldUnit='mm'; updateUI(); updateMeasurementsList(); currentScaleInfoEl.textContent = 'No Cal.'; }

// --- 8. INICIALIZACIÓN Y EVENTOS DE UI ---
document.addEventListener('DOMContentLoaded', () => {
    // Asignar eventos a todos los botones
    measureDistanceBtn.addEventListener('click', () => setActiveTool('distance'));
    measureAreaBtn.addEventListener('click', () => setActiveTool('area'));
    startCalibrateBtn.addEventListener('click', () => setActiveTool('calibrate'));

    finishShapeBtn.addEventListener('click', () => {
        if (currentTool === 'area' && currentPoints.length >= 3) {
            const area = calculateAreaShoelace(currentPoints) * (scaleFactor ? scaleFactor*scaleFactor : 1);
            allMeasurements.push({ type: 'area', pointsPdf: [...currentPoints], value: area, unit: realWorldUnit, pageNum: currentPageNum });
            updateMeasurementsList();
        }
        setActiveTool('none');
    });

    clearMeasurementsBtn.addEventListener('click', () => {
        if (confirm("¿Estás seguro de que quieres borrar todas las mediciones de esta página?")) {
            // Filtra para mantener solo las mediciones de otras páginas
            allMeasurements = allMeasurements.filter(m => m.pageNum !== currentPageNum);
            currentPoints = [];
            selectedMeasurementIndex = -1;
            updateUI();
            updateMeasurementsList();
        }
    });

    setScaleBtn.addEventListener('click', () => {
        const knownLength = parseFloat(knownLengthInput.value);
        if (isNaN(knownLength) || knownLength <= 0) { alert("Longitud inválida"); return; }
        if (currentTool === 'calibrate' && currentPoints.length === 2) {
            const pdfDist = calculateDistance(currentPoints[0], currentPoints[1]);
            scaleFactor = knownLength / pdfDist;
            realWorldUnit = knownUnitSelect.value;
            currentScaleInfoEl.textContent = `${scaleFactor.toFixed(4)} ${realWorldUnit}/pt`;
            calibrationInputDiv.style.display = 'none';
            setActiveTool('none');
        } else {
            alert("Primero dibuja una línea de calibración de dos puntos.");
        }
    });
    
    applyPredefinedScaleBtn.addEventListener('click', () => {
        const selected = predefinedScaleSelect.value;
        if (!selected) { alert("Selecciona una escala"); return; }
        // La conversión de unidades de dibujo a unidades reales es compleja.
        // Asumimos un estándar común: el dibujo está en mm y PDF a 72 DPI (puntos por pulgada).
        // 1 pulgada = 25.4 mm. 1 pulgada = 72 pt.
        // Factor de conversión base: (25.4 mm / 72 pt) = 0.35277... mm/pt
        const mm_per_pt = 25.4 / 72;
        
        const scaleRatio = parseFloat(selected);
        realWorldUnit = knownUnitSelect.value;

        // Factor base de mm por punto, ajustado por la escala del plano
        let factor = mm_per_pt * scaleRatio; // Ahora el factor está en (mm_reales / pt_pdf)

        // Ajustamos a la unidad seleccionada por el usuario
        switch(realWorldUnit) {
            case 'm':  factor /= 1000; break;
            case 'cm': factor /= 10; break;
            case 'mm': /* ya está en mm */ break;
            case 'ft': factor /= 304.8; break; // 1 ft = 304.8 mm
            case 'in': factor /= 25.4; break;  // 1 in = 25.4 mm
        }

        scaleFactor = factor;
        currentScaleInfoEl.textContent = `1:${scaleRatio} (${realWorldUnit})`;
        showTemporaryMessage(`Escala 1:${scaleRatio} aplicada.`, 'success');
        setActiveTool('none');
    });

    zoomInBtn.addEventListener('click', () => { currentRenderScale += ZOOM_FACTOR; renderPage(currentPageNum); });
    zoomOutBtn.addEventListener('click', () => { if (currentRenderScale > ZOOM_FACTOR) { currentRenderScale -= ZOOM_FACTOR; renderPage(currentPageNum); } });
    prevPageBtn.addEventListener('click', () => { if (pdfDoc && currentPageNum > 1) renderPage(currentPageNum - 1); });
    nextPageBtn.addEventListener('click', () => { if (pdfDoc && currentPageNum < pdfDoc.numPages) renderPage(currentPageNum + 1); });
    goToPageBtn.addEventListener('click', () => { if(pdfDoc) {const page = parseInt(goToPageInput.value); if (page >= 1 && page <= pdfDoc.numPages) renderPage(page);} });
    pdfFileInput.addEventListener('change', (e) => { if (e.target.files[0]) loadAndRenderPdf(URL.createObjectURL(e.target.files[0])); });
    
    measureCanvas.addEventListener('mousedown', handleMouseDownOnCanvas);
    measureCanvas.addEventListener('mousemove', (e) => {
        if (!pdfDoc) return;
        currentMousePosPdf = getPdfPoint(e.clientX, e.clientY);
        if (currentTool !== 'none' && currentPoints.length > 0) {
            redrawAllElements();
        }
    });

    // Carga inicial
    if (PDF_URL_TO_LOAD) {
        // Hacemos el código más robusto: solo manipulamos los elementos del DOM si existen.
        if (PDF_FILENAME && loadedPdfNameEl && pdfFileInput) {
            pdfFileInput.style.display = 'none';
            loadedPdfNameEl.textContent = PDF_FILENAME;
            loadedPdfNameEl.style.display = 'block';
        }
        loadAndRenderPdf(PDF_URL_TO_LOAD);
    }
});

// --- FUNCIÓN DE MENSAJES TEMPORALES ---
/**
 * Muestra un mensaje temporal en la pantalla.
 * @param {string} message - El texto a mostrar.
 * @param {string} type - El tipo de mensaje ('success', 'warning', 'error').
 */
function showTemporaryMessage(message, type = 'info') {
    const messageDiv = document.createElement('div');
    messageDiv.textContent = message;
    
    // Estilos del mensaje
    messageDiv.style.position = 'fixed';
    messageDiv.style.top = '20px';
    messageDiv.style.left = '50%';
    messageDiv.style.transform = 'translateX(-50%)';
    messageDiv.style.padding = '10px 20px';
    messageDiv.style.borderRadius = '5px';
    messageDiv.style.color = 'white';
    messageDiv.style.zIndex = '1050';
    messageDiv.style.opacity = '0';
    messageDiv.style.transition = 'opacity 0.3s ease-in-out';
    
    const colors = {
        warning: '#ffc107',
        error: '#dc3545',
        success: '#198754'
    };
    messageDiv.style.backgroundColor = colors[type] || '#0dcaf0';

    document.body.appendChild(messageDiv);

    // Animación de entrada y salida
    setTimeout(() => { messageDiv.style.opacity = '1'; }, 10);
    setTimeout(() => {
        messageDiv.style.opacity = '0';
        setTimeout(() => { document.body.removeChild(messageDiv); }, 300);
    }, 3000); // El mensaje dura 3 segundos
}